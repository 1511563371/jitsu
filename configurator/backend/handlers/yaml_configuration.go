package handlers

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/jitsucom/jitsu/configurator/destinations"
	"github.com/jitsucom/jitsu/configurator/entities"
	"github.com/jitsucom/jitsu/configurator/random"
	"github.com/jitsucom/jitsu/configurator/storages"
	enadapters "github.com/jitsucom/jitsu/server/adapters"
	endrivers "github.com/jitsucom/jitsu/server/drivers"
	"github.com/jitsucom/jitsu/server/middleware"
	enstorages "github.com/jitsucom/jitsu/server/storages"
	"gopkg.in/yaml.v3"
	"net/http"
)

const configHeaderText = `Generated by https://app.jitsu.com
Documentation: https://docs.eventnative.org

If executed out of our docker container and batch destinations are used, set up events logging
log:
  path: <path to event logs directory>
`

type ConfigHandler struct {
	configurationsService *storages.ConfigurationsService
	defaultS3             *enadapters.S3Config
}

func NewConfigurationHandler(configurationsProvider *storages.ConfigurationsService) *ConfigHandler {
	return &ConfigHandler{
		configurationsService: configurationsProvider,
		defaultS3: &enadapters.S3Config{
			AccessKeyID: "Please fill this field with your S3 credentials",
			SecretKey:   "Please fill this field with your S3 credentials",
			Bucket:      "Please fill this field with your S3 bucket",
			Region:      "Please fill this field with your S3 region",
		}}
}

type Server struct {
	Name    *yaml.Node         `json:"name" yaml:"name,omitempty"`
	APIKeys []*entities.APIKey `json:"auth" yaml:"auth,omitempty"`
}

type Config struct {
	Server       Server                                   `json:"server" yaml:"server,omitempty"`
	Destinations map[string]*enstorages.DestinationConfig `json:"destinations" yaml:"destinations,omitempty"`
	Sources      map[string]*endrivers.SourceConfig       `json:"sources" yaml:"sources,omitempty"`
}

func (ch *ConfigHandler) Handler(c *gin.Context) {
	projectID := c.Query("project_id")
	if projectID == "" {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Message: "[project_id] query parameter absents"})
		return
	}
	if !hasAccessToProject(c, projectID) {
		c.JSON(http.StatusUnauthorized, middleware.ErrorResponse{Message: "You are not authorized to request data for project " + projectID})
		return
	}

	//** API keys (auth) **
	keys, err := ch.configurationsService.GetAPIKeysByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to get API keys"})
		return
	}

	// ** Destinations **
	projectDestinations, err := ch.configurationsService.GetDestinationsByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to get Destinations"})
		return
	}
	mappedDestinations := make(map[string]*enstorages.DestinationConfig)
	for _, destination := range projectDestinations {
		destinationID := projectID + "." + destination.UID
		config, err := destinations.MapConfig(destinationID, destination, ch.defaultS3)

		if err != nil {
			c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to build destinations response"})
			return
		}
		mappedDestinations[destinationID] = config
	}

	// ** Sources **
	projectSources, err := ch.configurationsService.GetSourcesByProjectID(projectID)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to get Sources"})
		return
	}
	mappedSources := make(map[string]*endrivers.SourceConfig)
	for _, source := range projectSources {
		sourceID := projectID + "." + source.SourceID

		var destinationIDs []string
		for _, destinationID := range source.Destinations {
			destinationIDs = append(destinationIDs, projectID+"."+destinationID)
		}

		mappedConfig, err := mapSourceConfig(source, destinationIDs)
		if err != nil {
			c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Message: fmt.Sprintf("Failed to map source [%s] config", sourceID), Error: err.Error()})
			return
		}

		mappedSources[sourceID] = &mappedConfig
	}

	// building yaml response
	server := Server{APIKeys: keys, Name: &yaml.Node{Kind: yaml.ScalarNode, Value: random.String(5), LineComment: "rename server if another name is desired"}}
	config := Config{Server: server, Destinations: mappedDestinations, Sources: mappedSources}

	marshal, err := yaml.Marshal(&config)
	configYaml := yaml.Node{}

	if err = yaml.Unmarshal(marshal, &configYaml); err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed to deserialize result configuration"})
		return
	}
	configYaml.HeadComment = configHeaderText

	c.Header("Content-Type", "application/yaml")
	encoder := yaml.NewEncoder(c.Writer)
	defer encoder.Close()

	encoder.SetIndent(2)
	err = encoder.Encode(&configYaml)
	if err != nil {
		c.JSON(http.StatusBadRequest, middleware.ErrorResponse{Error: err.Error(), Message: "Failed write response"})
	}
}

# Retroactive User Recognition

**Jitsu** supports storing all events from anonymous users and updates them in DWH with user id after user identification.
At present this functionality is supported only for [Postgres](/docs/destinations-configuration/postgres), [Redshift](/docs/destinations-configuration/redshift), [ClickHouse](/docs/destinations-configuration/clickhouse-destination),
[Snowflake](/docs/destinations-configuration/snowflake) and [MySQL](/docs/destinations-configuration/mysql).

### Example

| event\_id | anonymous\_id | email |
| :--- | :--- | :--- |
| **event1** | 1 |  |
| **event2** | 1 |  |
| **event3** | 1 | a@b.com |
| **event4** | 1 | a@b.com |

Right after **event3** **Jitsu** amends **event1** and **event2** and adds email=[a@b.com](mailto:a@b.com). As a result, there will be the following events in DWH:

| event\_id | anonymous\_id | email |
| :--- | :--- | :--- |
| **event1** | 1 | **a@b.com** |
| **event2** | 1 | **a@b.com** |
| **event3** | 1 | a@b.com |
| **event4** | 1 | a@b.com |

<Hint>
    Fields anonymous_id and email are configurable. See <code inline="true">identification_nodes</code> below.
</Hint>

### Resources

In case if Retroactive Users Recognition feature is enabled - all incoming anonymous events (events JSON without filled `identification_nodes`) are saved in the users recognition storage (Currently only Redis is supported).
Events are saved under Redis key that contains user anonymous ID. Once any event with filled `identification_nodes` is received (identification event) - Jitsu updates these events in Data Warehouse and removes them from Redis.

<Hint>
    Redis can take up a significant amount of RAM. Read how to optimize Redis size in <code inline="true">Redis storage memory optimization</code> section below.
</Hint>

### Configuration

For enabling this feature, a global `users_recognition` must present in the configuration. The global configuration is applied to all destinations. It means that all events which are supposed to be stored into destinations of Postgres, Redshift, Snowflake, MySQL and ClickHouse types will be sent through the users recognition pipeline and all anonymous events will be stored into the users recognition storage. Configuration per destination overrides the global one.
For anonymous events storage Jitsu uses `meta.storage` by default, but you can specify separate redis in `users_recognition.redis` section. If you have high load then we highly recommend using separate Redis with [keys eviction](https://redis.io/topics/lru-cache). Otherwise Redis can take up a significant amount of RAM. Read more in `Redis storage memory optimization` section below.

<Hint>
    This feature requires:
    1. <code inline="true">users_recognition.redis</code> or <code inline="true">meta.storage.redis</code> configuration
    2. <code inline="true">primary_key_fields</code> configuration in Postgres, Redshift, MySQL destination.
    Read more about those settings on <a href="/docs/configuration/">General Configuration</a>
</Hint>



```yaml
server:
...

destinations:
  my_postgres:
    type: postgres
    datasource:
      host: my_postgres_host
      db: my-db
      ...
    data_layout:
      primary_key_fields: #Required for Postgres, Redshift users recognition feature
        - eventn_ctx_event_id
    #override global configuration completely (all fields)
    #omit this for applying global configuration
    users_recognition: #Optional
      enabled: true #set false for disabling
      anonymous_id_node: /user/anonymous_id #Required if enabled
      identification_nodes: #Required if enabled
        - /user/internal_id
        - /user/email

#Global configuration is applied to all destinations
#Example of compatible JS SDK 2.0 format
#For using with old format - just configure enabled flag:
#users_recognition:
#  enabled: true

users_recognition:
  enabled: true #Disabled by default.
  anonymous_id_node: /user/anonymous_id #Optional. Default value: /eventn_ctx/user/anonymous_id||/user/anonymous_id
  identification_nodes: #Optional. Default value: /eventn_ctx/user/internal_id||/user/internal_id
    - /user/internal_id
    - /user/email
  ## storage configuration (if not configured meta.storage will be used)
  redis:
    host: redis_host
    port: 6379
    password: secret_password
    ttl_minutes: #Optional. Anonymous events TTL in minutes. Default value: 10080 (7 days)
      anonymous_events: 10080 #7 days


## Meta storage configuration
meta:
  storage:
    redis:
      host: redis_host
      port: 6379
      password: secret_password
      ttl_minutes: #Optional. Anonymous events TTL in minutes. Default value: 10080 (7 days)
        anonymous_events: 10080 #7 days
```

<table>
  <thead>
    <tr>
      <th>Field</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>enabled</b>
      </td>
      <td>boolean</td>
      <td>Enabling/disabling this feature globally or for a certain destination</td>
    </tr>
    <tr>
      <td>
          <b>anonymous_id_node</b>
        <br />
        <em>(required)</em>
      </td>
      <td>string</td>
      <td>JSON path to user anonymous id. This value will be used as a part of the
        Meta storage key. Optional in global configuration, but required in destination
        configuration</td>
    </tr>
    <tr>
      <td>
        <b>identification_nodes</b>
          <br />
        <em>(required)</em>
      </td>
      <td>strings array</td>
      <td>JSON paths to identification nodes (e.g. user id and user email). If <b>ALL</b> identification values present in an input event - recognition pipeline will be started.
        If not - this event will be stored in the Meta storage as
        anonymous.
      </td>
    </tr>
    <tr>
      <td>
        <b>redis</b>
        <br />
        <em>(required if meta.storage isn't configured)</em>
      </td>
      <td>Object with Redis config</td>
      <td>Anonymous events storage. Can be omitted if meta.storage is configured and only one Redis will be used for both features. But for high load instances we highly recommend using separate Redis instance with key eviction. <code inline="true">Read more in Redis storage memory optimization</code> section.
      </td>
    </tr>
  </tbody>
</table>


### Redis storage memory optimization

Usually more then 50% of incoming traffic is from anonymous users (devices that haven't signed in yet). Jitsu uses Redis as a fast read/write storage.
Since Redis keeps all data in RAM even in slightly loaded projects storage can take up a significant amount of RAM and server memory may run out.

Approximately size of 1 anonymous event in Redis is `1KB`. So if your project has 10 requests per second and let's say 80% of them are anonymous - without user identifiers then:

`8 events * multiplying by 24 hours = 691 200 per day`. It is nearly 700MB of RAM per day.


The most reliable way to handle this problem is having a separate Redis instance for user recognition with finite memory and [keys eviction](https://redis.io/topics/lru-cache) configuration.
You can configure it with the following steps:

1. Specify Redis finite memory by adding:

`maxmemory: 25gb` into the `redis.conf` file or using command `CONFIG SET maxmemory 25gb`

<Hint>
    <code inline="true">CONFIG SET</code> command change current Redis configuration, but doesn't change the config file and after restart Redis will get configuration from file. Make sure that you have added new values to the configuration file after using <code inline="true">CONFIG SET</code> command.
</Hint>

2.



<!--

Jitsu uses Redis for users recognition storage. For small projects, anonymous events
It can be reduced by adding <code inline="true">ttl_minutes.anonymous_events</code> to <code inline="true">meta.storage</code> configuration (see below).
    TTL (time to live) is applied to Redis keys. It means that events from anonymous users that no longer visit your web pages will be deleted from Redis at the expiration time.

 -->
